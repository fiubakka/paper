% En esta sección se presenta una breve descripción de la solución que se propone, 
% el principal objetivo de esta sección es poder dar el bosquejo de la solución 
% para que pueda ser evaluado. No es necesario detalles, pero sí mencionar sus 
% componentes generales. 
% Si las tecnologías que se van a utilizar ya están establecidas, se deberán 
% incluir aquí. De no estar definidas todas, enumerar las que sí están definidas 
% y explicar qué consideraciones tendrán en cuenta para definir las restantes.

\noindent Como respuesta a las problemáticas presentadas anteriormente nosotros desarrollamos una arquitectura
completamente distribuida, opuesta totalmente al modelo monolítico prevaleciente en la industria de los videojuegos. 
El estado del juego no se encuentra restringido a un único nodo servidor, sino que se encuentra 
distribuido en varios, cada uno con igual importancia y responsabilidades que el resto. El conjunto del estado en cada uno de estos nodos compone el 
estado del juego en su totalidad.

El aspecto central del videojuego desarrollado es el uso que hace del \textbf{modelo de actores}.
Dicho modelo se basa en el \textbf{actor} como mínima unidad de cómputo y el pasaje de \textbf{mensajes} como única manera
de compartir información entre los actores. En la práctica, esto significa que toda la lógica del juego
es procesada por los actores, y la comunicación entre ellos se realiza únicamente mediante mensajes.
Este paradigma, ideado por Carl Hewitt en los años 70, eliminá varios de los problemas presentes
en la programación concurrente tradicional que mencionamos anteriormente, como
los \textit{deadlocks} y \textit{race conditions}, al eliminar el uso de memoria compartida
como herramienta de comunicación en el sistema.
Este modelo además resulta en una forma natural de representar a las entidades del videojuego, donde podemos plantear una 
relación \textbf{1 a 1} entre entidad y actor. Si además establecemos que el estado de cada entidad 
debería ser administrado por ella misma, otra característica intrínseca del modelo de actores,
se desprende entonces que se ajusta perfectamente a lo que queremos desarrollar.

Existen muchas implementaciones del modelo de actores. Algunas de ellas son estándar del lenguaje de programación,
como Erlang y Elixir, otras son bibliotecas de terceros que implementan el paradigma sobre lenguajes
agnósticos al mismo, como es el caso de la biblioteca Actix en Rust.
Nosotros decidimos utilizar Akka, un toolkit para construir aplicaciones concurrentes
y distribuidas que implementa el modelo de actores para la JVM (Java Virtual Machine).
Si bien Akka en sí está implementado en Scala, es compatible con otros lenguajes
basados en la JVM, como Java y Kotlin. Particularmente nos decantamos por utilizar Scala también
como lenguaje de programación del proyecto, ya que es el lenguaje nativo de Akka y cuenta con la documentación
más completa y actualizada.

Llegado a este punto, tenemos que el modelo de actores, y particularmente Akka, nos permite desarrollar un sistema distribuido
donde nuestra aplicación puede ejecutarse en N nodos de manera transparente, donde los distintos actores que residen en cada nodo
pueden comunicarse entre sí sin importar en qué nodo se encuentren y desconociendo la ubicación del otro actor con el que se comunican.
Más adelante entraremos en más detalle sobre el funcionamiento de Akka y los distintos componentes que utilizamos.

No alcanza sin embargo únicamente con Akka para poder desarrollar la arquitectura de nuestro videojuego.
El primer punto a resolver con el que nos encontramos es que necesitamos un mecanismo que nos permita comunicar distintos eventos
provenientes de un actor a otros N actores. Algunos de estos eventos pueden ser la actualización de las propiedades de uno de los jugadores,
como su posición y equipamiento, o las acciones que el jugador realice. Una primera solución que se podría plantear a esta problemática sería que cuando un jugador realice una acción,
por ejemplo de movimiento, sea responsabilidad de este notificar vía mensajes a todos los demás actores del juego que se ha desplazado. Esta solución sin embargo no es escalable, principalmente por dos motivos:

\begin{itemize}
    \item Cada actor correspondiente a un jugador debería almacenar una referencia a todos los demás jugadores para poder notificarles los eventos.
    Dados N actores en el sistema, esto generaría una complejidad espacial de O($N^2$).
    \item No contamos con un mecanismo que nos permita notificar a los demás actores que un nuevo actor se ha unido al sistema de forma automática.
    Para que un actor conozca a otro depende de haber recibido su dirección a través de un mensaje o haberlo creado él mismo.
\end{itemize}

El segundo punto podría resolverse si utilizamos un actor central el cual es el encargado de crear a todos los actores de los jugadores
y almacene las referencias a cada jugador creado, pero este mecanismo presenta un único punto de falla en el sistema, algo que queremos evitar a toda costa
para poder maximizar la distribución del modelo desarrollado.

Debido a esto, y siempre con el objetivo de maximizar la distribución del sistema minimizando los puntos de falla únicos del mismo,
decidimos hacer uso de otra herramienta distribuida, \textbf{Kafka}.

Kafka es un sistema distribuido de procesamiento de datos y almacenamiento de eventos caracterizado
por alto \textit{throughput} y baja latencia, características críticas para los sistemas de tiempo real.
Kafka se adapta perfectamente a lo que necesitamos para poder comunicar los eventos que los jugadores
realicen dentro del juego, y nos permite implementar un protocolo de comunicación de eventos entre los actores
de baja latencia, alta disponibilidad, tolerancia a fallos y escalabilidad horizontal.

Integrando Kafka en el sistema diseñamos un mecanismo de comunicación de eventos donde delegamos la lectura
y publicación de eventos en Kafka a actores específicos, de aquí en adelante denominados \textbf{Consumidores}
y \textbf{Productores}. Los Productores son los encargados de publicar en un tópico de Kafka los eventos de notificación masiva
que un jugador realice en el juego, como por ejemplo un movimiento o un mensaje de chat a la sala, y los Consumidores
son los encargados de leer estos eventos y notificar a los actores correspondientes a los demás jugadores.
Este último paso, la notificación del Consumidor a los demás jugadores de la partida, no es trivial de implementar.
A primera vista, volvemos al problema inicial de que deberíamos almacenar referencias a todos los actores del juego registrados
para poder enviarles los mensajes de notificación. Una forma de evitar esto podría ser proponer que cada jugador tenga un correspondiente
Consumidor, lo que tiene la ventaja de no introducir un punto único de falla. En la práctica sin embargo, los consumidores de Kafka consumen muchos recursos y
nuestro servidor sería incapaz de procesar una gran cantidad de jugadores.
Es aquí donde introducimos otro de los principales \textit{features} de Akka que nos permite resolver esta problemática:
\textbf{Akka Streams}.

Akka Streams es una implementación de Akka de la iniciativa \textit{Reactive Streams}, un estándar para el procesamiento de datos de forma asincrónica y no bloqueante.
En particular, Akka Streams permite definir \textit{pipelines} de procesamiento de datos a los cuales se les pueden aplicar distintas transformaciones y operaciones.
La clave detrás del uso de Akka Streams es que permite conectar múltiples fuentes de datos con múltiples consumidores de forma eficiente y sin bloqueos. Es similar a
lo que ya hacemos con Kafka, pero a nivel del nodo de la aplicación, es decir, internamente, y con la ventaja de consumir considerablemente menos recursos que con
consumidores de Kafka.

En resumidas cuentas, los eventos masivos se procesan de la siguiente manera:

\begin{itemize}
    \item Un jugador realiza una acción en el juego, como por ejemplo un movimiento.
    \item El actor correspondiente al jugador envía un mensaje al Productor con el evento.
    \item El Productor publica el evento en un tópico de Kafka.
    \item Un Consumidor lee el evento del tópico de Kafka y lo envía por un \textit{stream}.
    \item Cada uno de los demás jugadores del nodo recibe el evento a través del \textit{stream}.
\end{itemize}

// TODO agregar diagrama de lo descripto

Este diagrama resume el corazón de la arquitectura desarrollada. Es importante recordar que lo descrito corresponde a un único nodo del sistema.
La clave de la escalabilidad de la aplicación es que podemos replicarlo en N nodos, donde cada uno de ellos es responsable de un subconjunto de los actores del juego,
y la comunicación entre los actores de cada nodo es transparente, dando la ilusión de que la ejecución está contenida en un único nodo.

Afortunadamente, Akka cuenta con varias herramientas para conseguir esto. A continuación realizaremos un análisis de dichas herramientas y que papel juegan en la aplicación.

\subsection{Akka Actors Typed}

El corazón de Akka es el modelo de actores y, consecuentemente, el principal componente de Akka es la biblioteca
de actores. Históricamente Akka implementaba a los actores como clases de Scala que heredan de una clase \textbf{Actor}.
La clase luego debe definir un método \textit{receive} que se encarga de definir el comportamiento del actor según el mensaje recibido.
Dicho método recibe el mensaje como argumento del mismo, y el mensaje puede \textbf{ser cualquier tipo de dato de Scala}.
Mediante Pattern Matching, un feature nativo de Scala, se define el comportamiento del actor según el tipo de mensaje recibido.
El problema con esta metodología es que se pierde todo tipo de chequeo de tipos en tiempo de compilación.

Como respuesta a esta problemática, Akka introdujo una nueva versión de la biblioteca de actores llamada \textit{Akka Actors Typed}.
Esta nueva versión introduce el concepto de tipado para los mensajes que pueden recibir los actores, y además mantiene intercompatibbilidad
con los actores de la versión anterior, renombrada a \textit{Akka Actors Classic}.

A continuación se muestra una comparación entre la definición de un actor en la versión clásica y su análogo en la versión tipada de actores.

\newpage

\begin{lstlisting}[language=Scala, caption={\textbf{Ejemplo de Actor en Akka Actors Classic}}]
    import akka.actor.{Actor, ActorSystem, Props}

    // Define the messages
    case object Increment
    case object Decrement
    case object Print
    
    // Define the Counter actor
    class Counter extends Actor {
      var count = 0
    
      def receive = {
        case Increment => count += 1
        case Decrement => count -= 1
        case Print     => println(s"Current count is $count")
      }
    }
\end{lstlisting}

\begin{lstlisting}[language=Scala, caption={\textbf{Ejemplo de Actor en Akka Actors Typed}}]
    import akka.actor.typed.scaladsl.Behaviors
    import akka.actor.typed.{ActorSystem, Behavior}
    
    // Define the messages
    sealed trait Command
    case object Increment extends Command
    case object Decrement extends Command
    case object Print extends Command
    
    // Define the Counter actor
    object Counter {
      def apply(): Behavior[Command] = counter(0)
    
      private def counter(count: Int): Behavior[Command] = {
        Behaviors.receiveMessage {
            case Increment =>
                counter(count + 1)
            case Decrement =>
                counter(count - 1)
            case Print =>
                println(s"Current count is $count")
                Behaviors.same // Reuses the current behavior
        }
      }
    }
\end{lstlisting}

Como se puede observar, Akka Classic tiene un enfoque orientado a objetos para los actores.
El estado del actor se mantiene en variables de instancia y el comportamiento del actor se define en la función
\textit{receive} heredada de la clase \textit{Actor}. En cambio, Akka Typed tiene un enfoque funcional, donde el comportamiento
del actor se define mediante la función \textit{Behaviors.receiveMessage}, que es una \textit{factory} de comportamientos.
En Akka Typed un actor se define por su \textit{behavior}, el cual es una función que determina el comportamiento del actor
frente a todos los distintos mensajes que acepta. Luego de procesar cada mensaje debe devolverse el siguiente comportamiento.
El estado del actor se mantiene en los argumentos de la función comportamiento, y no en variables de la instancia.

Nuestro servidor de \textit{Fiubakka} hace uso exclusivo de la nueva API de Akka Typed, pero es importante estar al tanto
de la versión Akka Classic, ya que muchos proyectos existentes todavía la utilizan.

\subsection{Akka Cluster}

Anteriormente mencionamos que existen implementaciones del modelo de actores para distintas tecnologías. Si nos retringieramos
únicamente a utilizar el componente de actores de Akka no habría un motivo diferencial, más allá de la preferencia de lenguaje
o recursos disponibles en la web, para elegirlo sobre otras implementaciones. Akka Cluster es el primer motivo, y el más importante,
de por qué usamos Akka para implementar nuestro videojuego.

Akka Cluster extiende el modelo de actores de \textbf{forma transparente a la aplicación} para poder formar un \textit{cluster} de nodos de Akka,
comunicados entre sí, donde los actores pueden enviarse mensajes entre ellos sin importar el nodo en el que residan. Esto posibilita agregar
más poder de cómputo de forma \textbf{horizontal} al sistema. Siempre y cuando el problema que estemos resolviendo en Akka se beneficie de mayor
concurrencia y paralelismo, podemos agregar más nodos al cluster para distribuir la carga y conseguir mejores resultados en lugar
de tener que mejorar el hardware del sistema que tuviese que ejecutar la aplicación.

Para visualizar lo sencillo que es inicializar un cluster de Akka, esta es la configuración de \textit{Fiubakka}
para el ambiente local de desarrollo:

\newpage

\begin{lstlisting}[language=applicationconf, caption={\textbf{Configuración de Akka Cluster Fiubakka}}]
    cluster {
        downing-provider-class = "akka.cluster.sbr.SplitBrainResolverProvider"
        shutdown-after-unsuccessful-join-seed-nodes = 60s
        seed-nodes = ["akka://fiubakka-server@127.0.0.1:2020"]

        sharding {
            number-of-shards = 100
            least-shard-allocation-strategy.rebalance-absolute-limit = 20
            buffer-size = 300000
            updating-state-timeout = 15 s
        }
    }
\end{lstlisting}

Para el ambiente local se utilizan lo que se denomina como \textit{seed nodes}, que son nodos que se encargan de iniciar el cluster.
Al iniciar un nodo de Akka el mismo verifica si su dirección corresponde a un seed node. Si es así, se encargará de escuchar futuras
conexiones de otros nodos de Akka que busquen unirse al cluster, y siempre que un nodo de Akka no seed se inicie intentará conectarse a los seed nodes especificados
en la configuración. Por supuesto, este método únicamente funciona si las direcciones de los nodos son estáticas y conocidas de antemano.
Para ambientes dinámicos como Kubernetes existen otros métodos de descubrimiento de nodos que describiremos más adelante.

La sección de \textit{sharding} incluida en la configuración nos lleva a nuestro siguiente componente de Akka del que \textit{Fiubakka}
hace uso: \textbf{Akka Cluster Sharding}, una extensión de las funcionalidades que Akka Cluster provee.

\subsubsection{Akka Cluster Sharding}

Una problemática que surge al utilizar Akka Cluster es que si bien los actores pueden comunicarse entre sí sin importar en qué nodo
se encuentren, el problema es conseguir en primera instancia la referencia a actores que residen en otros nodos ajenos al propio. En principio
pueden utilizarse llamados remotos a los demás nodos y conseguir como respuesta las direcciones de los actores que nos interesan para poder
crear la referencia a los mismos, pero no es ideal. Por otro lado, una propiedad deseable en los sistemas distribuidos es la capacidad
de esparcir la carga entre los distintos nodos \textbf{elásticamente}, esto es, que el incremento y decremento de nodos en el cluster
resulte en un balanceo uniforme de la carga total.

Akka Cluster Sharding es, entre otras cosas, una respuesta a ambos puntos. Permite crear \textbf{entidades} que pueden ejecutarse en cualquier nodo
del cluster y que pueden ser referenciadas desde cualquier nodo por medio de un identificador único, para poder comunicarnos con las mismas.
Podemos pensar a una entidad como un actor que reside en un único nodo del cluster en todo momento, y al cual podemos conseguir una referencia sin saber
en qué nodo se encuentra, utilizando su identificador.

Además, Sharding nos permite definir una \textbf{estrategia de balanceo} de las entidades al momento de creación de las mismas,
y de \textbf{rebalanceo} modificarse la composición de los nodos del cluster. Nuevamente, para nuestra aplicación, estos balanceos son
completamente transparentes. Si un nodo se cae, las entidades que residían en el mismo son automáticamente reubicadas en otros nodos del cluster,
y los distintos actores que estuviesen comunicandose con dichas entidades no se enterarán del cambio.

Sin adentrarnos demasiado en los detalles, Cluster Sharding consigue implementar esto de la siguiente forma.
En primer lugar, cada entidad tendrá definido por cada tipo de entidad lo que se conoce como un \textit{Shard Coordinator}, un actor singleton
que residirá en el nodo líder del Akka Cluster y será el responsable de determinar en que nodos del cluster residirá
un \textit{shard}. Los shards son conjuntos de entidades, donde cada entidad tiene un shard asignado mediante un hash calculado sobre su
identificador único. En este sentido, la mínima unidad asignable por el Shard Coordinator es el shard, y no entidades individuales (de allí su nombre).
Cada nodo tendrá lo que se denomina un \textit{Shard Region} por cada tipo de entidad, un actor que se encargará de administrar los shards del nodo
que le hayan sido asignados por el Coordinator, así como resolver, también mediante en el Shard Coordinator en caso de ser necesario, las ubicaciones
de los shards cuyas entidades sean comunicadas por los actores del nodo.

En el caso de nuestra aplicación \textit{Fiubakka}, cada cliente que se conecta al juego va a generar dos entidades asociadas: una entidad
\textbf{Player} y otra entidad \textbf{PlayerPersistor}. La ventaja de representar a los jugadores como entidades en lugar de actores es justamente que conseguimos
referenciar a un jugador sin conocer ni importar el nodo en el que reside, y que además son sujetos a los procesos de balanceo de carga que se hace sobre las entidades.
Esto nos permite escalar horizontalmente frente al incremento de jugadores en el juego, mediante simplemente agregar más nodos de forma dinámica.

\newpage

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{../assets/cluster-sharding-example.jpeg}
    \caption{Ejemplo de Cluster Sharding para la entidad Player}
\end{figure}

Es claro entonces la importancia que tiene Cluster Sharding en nuestro modelo, y tiene un papel fundamental, junto con Akka Cluster, en permitirnos desarrollar nuestra arquitectura
propuesta. Implementaciones del modelo de actores como \textit{Actix} no cuentan con ningún feature similar. Por otro lado, Elixir sí que cuenta con capacidades similares a las de Akka
Cluster, aunque no las de Cluster Sharding ni las del siguiente componente clave: Akka Persistence.

\subsection{Akka Persistence}

Cluster Sharding nos da la garantía de que las entidades se reinician en caso de error o eliminación de un nodo del cluster, además de rebalancearlas al agregarse un nuevo
nodo. En principio, únicamente con los componentes de Akka que presentamos hasta ahora, ambos casos resultan en un problema: si la entidad se vuelve a iniciar, estaríamos perdiendo el estado
de la misma, ya que el estado de los actores está en memoria. Esto resultaría por ejemplo en perder los datos de posición del jugador, o también su inventario o equipamiento.
En arquitecturas \textit{stateless}, el estado sería persistido en una base de datos externa ante cada cambio sucedido.
Una propuesta más que válida sería persistir el estado del actor serializado como si se tratase de un objeto. Akka Persistence toma esta idea y la integra nativamente en los actores. 

Existen dos \textit{flavors} o implementaciones de Akka Persistence. La primera es Event Sourcing, la cual se basa en un proceso de replay de eventos. Cada evento sucedido genera en respuesta
un comando que es procesado por el actor, y el procesamiento de todos los comandos provenientes de los eventos determina el estado final del actor. Lo que se persisten en ese caso son justamente los eventos.
En caso de que el actor se reinicie, se leen los eventos persistidos y se reenvían los comandos correspondientes al actor para volver al estado en el que se encontraba previo a su caída.
Lógicamente, dado que en el tiempo pueden acumularse muchos eventos, se introduce un concepto de \textit{snapshot} del estado del actor que actúa como un checkpoint. Cada N cantidad de eventos
se almacena el snapshot del estado del actor y se reinician los eventos persistidos, tomando ese snapshot como estado inicial del actor previo al reprocesamiento de los eventos. Esto evita que las inicializaciones
del actor sean muy costosas en tiempo.

Esta primera versión resulta útil en sistemas donde llevar un registro de los sucesos resulte valioso. En el caso de \textit{Fiubakka} no nos interesa entender los eventos
que llevaron al estado actual de un jugador, únicamente necesitamos el estado del jugador cada ciertos instantes o acciones.
Afortunadamente, Akka Persistence introdujo en una de sus últimas versiones otra alternativa llamada \textbf{Durable State}.

Durable State permite definir \textit{behaviors} que se caracterizan por generar lo que se denomina un \textit{effect} por cada comando recibido en el actor.
En la nomenclatura funcional, la cual vimos anteriormente que Akka Typed utiliza, un efecto hace referencia a una acción secundaria al resultado de la función.
Dado que en Akka Typed todo mensaje que un actor procesa tiene como resultado de la función el nuevo comportamiento, los efectos incluyen acciones como persistir el estado del actor
en la base de datos o responder al actor que envió el mensaje.

Este modelo de persistencia de actores se ajusta casi perfectamente a lo que buscamos para persistir el estado de los actores de los jugadores.
El único problema, en la práctica, es que la API de Durable State Behavior es algo limitada. No es posible por ejemplo tener como efecto tanto la persistencia del actor
como la respuesta al actor que envió el mensaje. Además, en el caso de generar como efecto la peresistencia del estado del actor, el mismo no procesará el siguiente mensaje hasta no haberse
ejecutado la query de almacenamiento en la base de datos. Dado que la ejecución de queries puede llevar un tiempo no despreciable comparado con la velocidad de los actores en el procesamiento de los mensajes,
preferimos no utilizar Durable State Behavior directamente sobre los actores \textbf{Player} asociados a cada cliente del juego.
En cambio, definimos otro actor \textbf{PlayerPersistor} que sí utiliza Durable State Behavior y al cual el Player le envía su estado en un mensaje.
De esta forma desacoplamos la persistencia del estado del jugador del procesamiento de los eventos que reciba, evitando incrementar la latencia y empeorar la experiencia del juego.

Dado que un jugador puede recibir miles de mensajes por segundo de distintos eventos que van sucediendo en el juego, optamos por enviar el mensaje de persistencia al
PlayerPersistor cada cierta cantidad de segundos para alivianar la carga en la base de datos. En la práctica perdernos unos segundos de movimiento del jugador es irrelevante, ya que ante eventos
importantes (por ejemplo cuando el jugador se desconecta) persistimos el estado inmediatamente, por lo que en general el jugador verá su estado de forma correcta
al reconectarse al juego.

A continuación se muestra la implementación del \textbf{PlayerPersistor}, el actor responsable de persistir el estado del jugador en el servidor.

\begin{lstlisting}[language=Scala, caption={\textbf{Implementación del PlayerPersistor}}]
object PlayerPersistor {
    sealed trait Command extends CborSerializable
    final case class Persist(newState: DurablePlayerState) extends Command
    final case class GetState(replyTo: ActorRef[GetStateResponse]) extends Command
    
    final case class GetStateResponse(state: DurablePlayerState)
        extends CborSerializable
    
    val TypeKey = EntityTypeKey[Command]("PlayerPersistor")
    
    def apply(persistenceId: PersistenceId): Behavior[Command] = {
        DurableStateBehavior[Command, DurablePlayerState](
        persistenceId,
        emptyState = DurablePlayerState(
            "",
            Position(845, 1730),
            Equipment(0, 0, 0, 0, 0, 0, 0),
            0
        ),
        commandHandler = commandHandler
        )
    }
    
    private def commandHandler(
        state: DurablePlayerState,
        command: Command
    ): Effect[DurablePlayerState] = {
        command match {
        case Persist(newState) => {
            Effect.persist(newState)
        }
        case GetState(replyTo) => {
            replyTo ! GetStateResponse(state)
            Effect.none
        }
        }
    }
}
\end{lstlisting}

Nótese como el PlayerPersistor combina el concepto de entidad de Akka Cluster Sharding con el de persistencia de Akka Persistence. En la práctica, ambos están muy relacionados,
ya que las entidades suelen tener un estado asociado que necesita ser recuperable.

Como base de datos para la persistencia tanto del estado de los actores como de otros registros de información utilizamos
\textbf{PostgreSQL}. Otras opciones que Akka Persistence soporta nativamente son Cassandra y MongoDB.

\subsection{Akka Streams}

El último componente principal de Akka que utilizamos es uno que mencionamos en el resumen de la arquitectura, Akka Streams.
Se trata de una implementación de la iniciativa de Reactive Streams, un estándar para el procesamiento de datos de forma asincrónica y no bloqueante.
Conceptualmente, se trata de un \textit{pipeline} de procesamiento de datos, donde tenemos tres componentes principales: el \textbf{Source},
el \textbf{Flow} y el \textbf{Sink}. El Source es la fuente de los datos, el Flow es una etapa interna del pipeline que transforma los datos, y el
Sink es el consumidor final. Todo Stream tiene al menos un Source y un Sink, y puede tener cualquier cantidad (o ningún) Flow entremedio.

Un Stream es un maquetado o \textit{blueprint} de cómo los datos van a ser procesados. La acción de construir el Stream y ejecutarlo se denomina
\textit{materializar} el Stream. El Stream puede ser materializado una única vez, ya que la fuente de datos (Source) puede ser consumida una única vez.

Se trata de una herramienta particularmente útil para procesar grandes cantidades de datos de forma eficiente. Cada etapa del Stream puede ser procesada
concurrentemente en distintos threads, lo que garantiza un alto \textit{throughput}. Es posible construir pipelines extremadamente complejos de forma relativamente
sencilla, y cuenta con muchos operadores nativos que facilitan la construcción de los mismos. Es una herramienta que no apunta a la simplicidad de uso, pero que provee todos los elementos
básicos necesarios sobre los cuales puede construirse prácticamente cualquier solución.

\newpage

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{../assets/akka-stream-example.png}
    \caption{Ejemplo de un Stream lineal con N Flows, un Source y un Sink}
\end{figure}

TODO continue

\subsubsection{Introducción a Akka}

\subsubsection{Arquitectura}

\subsubsection{Diagramas}

\subsubsection{Mensajes de Kafka}

Como fue explicado anteriormente, para la comunicación de eventos utilizamos Kafka mediante actores especializados para la
lectura y escritura llamados \textbf{Consumidores} y \textbf{Productores} respectivamente. Dichos actores operan sobre
mensajes que contienen información relacionada a un evento. Para serializar los mensajes de una forma eficiente usamos
la herramienta Protobuf, explicada en detalle en la sección 8.4.

\subsection{Frontend: cliente Godot}

\noindent \textit{Godot} es un motor para desarrollo de videojuegos, de origen argentino, gratuito y de código abierto. 
Este motor brinda distintas herramientas para desarrollar aplicaciones interactivas, como por ejemplo 
interfaces gráficas, gráficos 2D y 3D, input del usuario con distintos periféricos, control de audio, 
lógica de físicas y colisiones, conectividad a través de la red, entre muchas otras.
Además de permitir desarrollar para múltiples plataformas, permite programar scripts exponiendo una 
API orientada a objetos en los lenguajes C++, C\# e incluso GDScript, un lenguaje propio de Godot. 

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{../assets/godot-engine-showcase.png}
    \caption{Editor de Godot Engine. 
            Source: https://docs.godotengine.org/en/stable/getting\_started/introduction/introduction\_to\_godot.html}
\end{figure}

\textit{GDScript} es un lenguaje de programación de alto nivel y con sintaxis similar a Python. 
El hecho de que sea un lenguaje interpretado tiene la ventaja de que no es necesario volver a compilar 
todo el código cada vez que se hacen modificaciones sobre el mismo.
A partir de la versión 4.0 de Godot, GDScript ofrece soporte opcional de tipado estático, el cual puede
mejorar la performance en runtime y aumenta la eficiencia del código.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{../assets/godot-editor.png}
    \caption{Editor de código de Godot.}
\end{figure}

El motor ofrece una amplia colección de Nodos, que son los componentes básicos que se utilizan para 
construir Escenas. A su vez, estas escenas pueden ser sub-nodos de otras escenas. Los Nodos pueden ser desde un 
simple botón (\textbf{Button}) hasta un cuerpo tridimensional con lógica de físicas y colisiones 
(\textbf{PhysicsBody3D}) e incluso un \textbf{AnimationPlayer} que se encarga de manejar animaciones, 
es decir, una secuencia de imágenes o \textit{Sprites}.

Estos nodos no solamente son modificables y configurables como se desee, sino que además se les puede 
añadir un script, extendiendo y personalizando su comportamiento como sea necesario.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{../assets/godot-editor.png}
    \caption{Interfaz gráfica del editor de Godot. Los componentes enumerados son el árbol de nodos (1),
            el explorador de archivos (2), el editor de la escena (3), el panel de animaciones (4) y el
            inspector del nodo seleccionado (5).}
\end{figure}

Otro feature importante de Godot es el uso de señales (\textit{signals}) para comunicar eventos entre nodos.
Un Nodo cualquiera o una Escena personalizada pueden emitir \textit{signals} con un nombre específico 
(incluso con parámetros) para que otros Nodos o Escenas se suscriban a dicha señal. Al suscribirse, los 
Nodos receptores definen un handler (comúnmente nombrado \textit{\_on\_node\_signal\_name}) para manejar 
la señal recibida. De esta forma se pueden crear escenas compuestas de múltiples Nodos distintos, con 
comportamiento más complejo, pero sin acoplar todos los nodos que necesiten comunicarse entre sí.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{../assets/godot-signals.png}
    \caption{Ejemplo de conexión de una signal. Cuando el nodo LoginUsername emite la signal
            username\_submitted, el nodo Login la recive en su función \_on\_login\_username\_text\_submitted}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{../assets/godot-signals-diagram.png}
    \caption{Diagrama del flujo de emisión de una signal. Primero se define la señal text\_submitted
            en el nodo LoginUsername y se la conecta al nodo Login (que es padre de LoginUsername).
            Al emitirse esta señal, Login la escucha y entonces ejecuta su función handler
            \_on\_login\_username\_text\_submitted}
\end{figure}

La filosofía del diseño de Godot es construir escenas reutilizables usando nodos. A estas escenas y 
nodos se les puede agregar comportamiento con \textit{scripts}. Con la composición y jerarquía de los Nodos, 
se puede construir una lógica de juego que es clara y fácil de entender.
Es por estas características de cohesión, simplicidad y eficiencia en el diseño de Godot, así
como también el tipo de herramientas que provee que optamos por usar este motor para el desarrollo del
frontend del proyecto en lugar de crear módulos de autoría propia con un lenguaje de más bajo nivel, 
como por ejemplo C o C++.

\subsubsection{Estructura de proyecto}

\noindent A continuación detallamos nuestra implementación del frontend utilizando las herramientas descriptas
anteriormente, cómo las aplicamos y los motivantes.

Para este proyecto, definimos una Escena \textbf{Main} donde se instancian las escenas más importantes 
del juego, necesarias para el funcionamiento del mismo. Por ejemplo, es en este nodo donde se instancian
escenas como el Menú Principal (\textbf{MainMenu}), las pantallas de login (\textbf{Login} y \textbf{CharacterCreation}) y los nodos necesarios para la conexión 
con el Servidor (\textbf{ServerConsumer}, \textbf{ServerProducer}, entre otros).
Los niveles propiamente dichos no se instancian al iniciar el juego, sino una vez que el jugador 
se haya conectado al servidor y luego a medida que se mueve por las distintas zonas del juego.
De esta forma, encapsulamos todas las escenas activas en un mismo lugar y 
no desperdiciamos recursos instanciandolas a la vez, solo se instancian las escenas que
se van a usar.

Cuando un jugador ejecuta por primera vez el juego, lo primero que verá es la escena del menú principal, 
o \textbf{MainMenu}. Luego de elegir el idioma del juego, tendrá dos opciones diaponibles: ingresar al juego
con un usuario existente desde el \textbf{Login} o crear un personaje y un usuario en \textbf{CharacterCreation}.

% TODO: imagen MainMenu

Si el usuario opta por ingresar al juego a través de \textbf{Login}, deberá ingresar con un nombre de usuario
y contraseña existentes. En caso de haber algún error de login, se mostrará por pantalla según el error 
correspondiente, como por ejemplo credenciales inválidas. Como el sistema de autenticación de usuario no
fue el foco de este proyecto, no es posible recuperar la contraseña de un usuario ni tampoco darlo de baja.

% TODO: imagen Login

Por otro lado, si se tratase de un nuevo jugador o si uno existente desea crear otro personaje, el usuario
puede entrar a la pantalla de registro (o \textbf{CharacterCreation}) donde podrá ingresar sus nuevas
credenciales de usuario y también personalizar la apariencia de su nuevo personaje. En esta pantalla
se visualiza del lado izquierdo un \textit{sprite} del personaje que será creado y a la derecha una
lista de selectores para los distintos cosméticos que componen al \textit{sprite}. El usuario podrá elegir
agregar, combinar e incluso quitar los cosméticos de su personaje a su gusto. Una vez que haya hecho su elección
e ingrese sus credenciales, se crea el usuario correspondiente.

% TODO: imagen CharacterCreation

Además hacemos uso de los \textbf{Autoloads} de Godot, que funcionan igual que clases \textbf{Singleton}
del patrón de diseño del mismo nombre. Estos Autoloads se cargan en el arbol de escenas desde el comienzo
y están siempre disponibles sin importar cual es la escena actualmente corriendo. Un detalle importante es que
estos Autoloads simplemente \textit{actúan} como Singletons, pero no son realmente Singletons (podrían instanciarse
más de una vez cada uno).
Se definieron ciertas clases (scripts) que son necesarios en un scope global como Autoloads.
Por ejemplo, para el manejo, carga y borrado de escenas, hacemos uso de un \textbf{SceneManager}, 
que es un script Autoload que permite transicionar entre niveles dentro del juego. En general, 
se implementaron Singletons de tipo \textit{Manager} para acceder a distintos comportamientos y 
configuraciones globales (información del jugador, cambio de escenas, control del audio, entre otros).

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.4\textwidth]{../assets/godot-scene-tree-1.png}
    \caption{Arbol de nodos (Scene Tree) en la pantalla principal del juego}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.4\textwidth]{../assets/godot-scene-tree-2.png}
    \caption{Arbol de nodos cuando el jugador está en un nivel del juego}
\end{figure}

Cada nivel es una instancia de la clase \textbf{Level}. Si bien cada escena de nivel creada es diseñada
de forma especial para replicar alguna parte de la arquitectura de la Facultad de Ingeniería,
existen ciertos tipos de nodos que deben usarse en todos los niveles.
Por ejemplo, para definir la forma, apariencia y estructura de cada nivel, debe tener un TileMap,
que es un tipo de nodo que a partir de una \textit{SpriteSheet} permite "pintar" sobre
una grilla predefinida de pixeles, como si fuera un canvas. Además se deben definir las colisiones de las 
"paredes" de cada nivel, para que el jugador no se pase del límite de la cámara y se vaya 
\textit{out of bounds}. Esto se logra con nodos del tipo \textbf{StaticBody2D} y \textbf{CollisionShape2D}.
Otro nodo importante en un nivel es el \textbf{Player}, ya que cada nivel debe incluir su propio jugador.
Esto quiere decir que no instanciamos un solo nodo \textbf{Player} y lo transferimos entre los distintos 
\textbf{Levels}, sino que cada \textbf{Level} debe instanciar su propio \textbf{Player}. Esta implementación
simplifica la transferencia de data necesaria entre niveles.
También son importantes las puertas o \textbf{Doors} en los niveles, ya que estas cumplen la función de
permitirles a los jugadores cambiar de nivel y moverse a través de la Facultad.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{../assets/levels-tree-nodes.png}
    \caption{Ejemplos de árboles de nodos para distintas escenas de tipo \textit{Level}. Nótese que
            comparten ciertos tipos de nodos en común (\textbf{Player}, \textbf{TileMaps},
            \textbf{CollisionShape2D}, etc.)}
\end{figure}

Como se mencionó anteriormente, para transicionar entre niveles, es decir, para cargar un nuevo Level
y remover el actual, implementamos un script Autoload llamado \textbf{SceneManager}.
Este SceneManager encapsula la responsabilidad de manejar el cambio de niveles de forma natural para 
el usuario. El proceso para cambiar de un Level a otro es:
\begin{itemize}
    \item Mostrar una escena de pantalla de carga (\textbf{LoadingScreen}).
    \item Cargar de memoria la nueva escena en un hilo separado.
    \item Una vez cargada la escena nueva, montarla en el arbol de escenas.
    \item Antes de remover la escena actual, transferir cualquier tipo de data relevante de un nive la otro,
    como por ejemplo el equipamiento del jugador.
    \item Remover la escena actual.
    \item Remover la \textbf{LoadingScreen}.
\end{itemize}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{../assets/godot-loading-screen.png}
    \caption{Pantalla de carga.}
\end{figure}

Un \textbf{Player} o jugador es una escena donde se encapsulan tanto la vista como el comportamiento del
personaje que controla el usuario. Está compuesto tanto de \textbf{CompositeSprites} para la visualización
de los cosméticos elegidos en la pantalla de creación del personaje, como de \textbf{CollisionShape2D} para
la detección de colisiones con las paredes u otros objetos del nivel donde se encuentre.
Además es esta escena la que contiene una \textbf{Camera2D}, que representa la vista que el usuario tendrá
del juego en el textit{viewport} de su pantalla. Al ser un subnodo del \textbf{Player}, logramos un efecto donde la
cámara sigue al jugador a donde sea que vaya, como es usual en este tipo de juegos. Cabe destacar que se 
definieron coordenadas límites para la cámara (o \textit{bounds}) para evitar que se muestre regiones por
fuera del perímetro de cada mapa.
Otro nodo notable es el \textbf{AnimationPlayer}, el cual permite definir animaciones para el jugador
(por ejemplo, \textit{idle} o \textit{walking}) definiendo cuál \textit{Sprite} debe mostrarse en cada
\textit{frame} de la animación.

Dos escenas muy similares al \textbf{Player} son las \textbf{Entities} y los \textbf{NPCs}.
Ambos cuentan con los mismos nodos que un \textbf{Player} (\textbf{CompositeSprites}, \textbf{CollisionShape2D},
\textbf{AnimationPlayer}), pero la principal diferencia es que estas escenas no son controladas por el jugador.
Una \textbf{Entity} es el personaje de otro jugador conectado. Un \textbf{NPC} es un personaje no jugable
(o \textit{Non-Playable Character}). El jugador puede interactuar con ambos de distintas formas.

Una vez dentro de la Facultad, el jugador podrá moverse a través del nivel usando las cuatro flechas teclas
direccionales del teclado o \textbf{WASD}.
También podrá acceder a un inventario presionando la tecla \textbf{I}.
Dentro de este inventario verá listados los objetos que tenga disponible, ya sean objetos personales u otros
cosméticos. En el caso de los cosméticos, podrá optar por equipar o desesquiparselos, modificando la
apariencia de su personaje.
Además al presionar la tecla \textbf{TAB} abrirá una ventana de chat, donde podrá intercambiar mensajes con
todos los otros jugadores que estén conectados en la misma región de la Facultad. Mientras esté chateando,
el jugador no podrá moverse y tendrá cerrar la ventana de chat presionando \textbf{TAB} nuevamente.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{../assets/godot-inventory.png}
    \caption{Inventario de items.}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{../assets/godot-chat.png}
    \caption{Chat.}
\end{figure}

Uno de los principales features del juego es la posibilidad de desafiar a otros jugadores a una partida de 
Truco. El Truco es un juego de cartas argentino que se juega con naipes españoles. El objetivo del juego
es obtener 30 puntos antes que el oponente, ganando las manos y haciendo disitntas jugadas con cantos.
Para desafiar a otro jugador a una partida de Truco, el usuario solo debe hacer click derecho sobre cualquier
otro personaje que vea en su pantalla. Eso habilitará un submenú con un botón para jugar al Truco.
El otro jugador recibirá una notificación que puede aceptar o rechazar. Al aceptarla, ambos jugadores
verán la pantalla de Truco y la partida comienza.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{../assets/godot-truco-menu.png}
    \caption{Submenú de jugador. A partir de este menú se puede desafiar a otro jugador al Truco.}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{../assets/godot-truco-notification.png}
    \caption{Notificación de Truco. El jugador puede rechazarla o aceptarla y empezar la partida inmediatamente.}
\end{figure}

Los jugadores verán las cartas de su mano en la región inferior de la pantalla, así como también las opciones
de cantos disponibles en dicho turno. Para hacer un canto, solo deben clickear el botón correspondiente
y esperar la respuesta del oponente. Para jugar un carta, el jugador que corresponda podrá arrastrarla con el
mouse desde su mano y soltarla sobre la mesa en la región que corresponda al turno que está transcurriendo,
haciendo \textit{drag and drop}. El otro jugador va a ver la carta jugada por su oponente y se le hailitará
que juegue su turno, si aún no terminó la ronda.
La partida termina cuando un jugador llega a acumular 30 puntos o en caso de que alguno abandone, ya sea 
voluntariamente o en caso de alguna desconexión.
Todas las reglas del Truco así como también el control del transcurso de la partida y del \textit{game state}
están implementadas en el Servidor. El Cliente solo funciona a modo de \textit{frontend} para que los
usuarios puedan jugar.

% TODO: dejar 1 sola captura indicando con recuadros que significa cada parte de la UI
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{../assets/godot-truco-1.png}
    \includegraphics[width=0.8\textwidth]{../assets/godot-truco-2.png}
    \caption{Pantalla de Truco durante una partida en transcurso. Las cartas y los cantos dispnibles se
            ven en la región inferior y las cartas se juegan sobre la mesa.}
\end{figure}
 
% TODO: poner en algun lado como se mueve el jugador (controles)
Todos los controles del juego están detallados en el apéndice.


\subsubsection{Comunicación con el servidor}

\noindent Al comienzo del proyecto, un posible limitante de usar Godot eran las herramientas que podía ofrecer 
el motor para la conectividad con el servidor, ya sea UDP, TCP o incluso HTTP. 
Para nuestro beneficio, Godot provee distintas APIs para conectividad que cumplen los requisitos
de los protocolos antes mencionados. En nuestro caso, decidimos usar el protocolo TCP por sus características:
\begin{itemize}
    \item Handshake con el Servidor
    \item Conexión mantenida con el Servidor
    \item Garantía de recepción de todos los paquetes enviados
    \item \textit{Flow Control}
\end{itemize}

Luego, definimos nuestras propias clases \textit{wrapper} para establecer la conexión al servidor y el 
manejo de mensajes. 

Para la recepción implementamos un \textbf{ServerConsumer} que se encarga de recibir los paquetes 
del Servidor, parsea el mensaje completo (ver sección Protocol buffers) y según qué mensaje recibió, 
invoca al \textit{handler} correspondiente para actualizar el estado del juego del lado del Cliente.
Este \textbf{ServerConsumer} se ejecuta en un thread aparte, para no bloquear el thread principal mientras
esperamos recibir un mensaje. Sin embargo, luego de parsear un mensaje recibido, el \textit{handler}
correspondiente se ejecuta en el thread principal.

Es análogo el envío de mensajes en el sentido desde el Cliente hacia el Servidor: algún input de un 
usuario dispara una \textit{signal} que el \textbf{ServerProducer} recibe, este se encarga de crear 
el mensaje correspondiente con los parámetros correctos, lo serializa y envía los paquetes de bytes 
al Servidor a través de la conexión TCP.

\subsection{Comunicación entre cliente y servidor}


\subsubsection{Lógica del juego: movimiento y colisiones}
\noindent Otro de nuestros problemas iniciales fue decidir cómo implementaríamos el movimiento del 
jugador. Al tratarse de un juego online, lo ideal era que la lógica fuera mayormente implementada del 
lado del servidor y así garantizar que los jugadores no pudieran realizar movimientos prohibidos, como 
ir a zonas que no estuvieran permitidas u obtener algún tipo de ventaja. Con este acercamiento del 
problema, Godot no debería hacer más que enviar los inputs de la dirección a la que se desea mover el 
jugador del jugador, y dejar que el 
servidor se encargara de verificar que se tratase de un input válido, calcular el efecto de este 
input en la posición y enviar a Godot la nueva dirección para que se viera reflejada en el juego.

Este acercamiento sirvió en un inicio donde el juego era un prototipo donde no teníamos definidos 
mapas con un perímetro definido, sin embargo empezaron a verse las faltas en esta solución cuando 
se comenzó a implementar las colisiones del jugador con los mapas y los objetos dentro de sus límites.

Se decidió ceder la mayor parte de la lógica del movimiento a Godot debido a que este provee 
su propio sistema de colisiones, aprovechando las herramientas que provee sin reinventar un sistema 
colisiones. Este acercamiento nos hacía renunciar a que el input fuera 
verificado con cada movimiento, pero facilitaba de forma significativa la implementación del 
movimiento y las colisiones. Debido a que nuestro juego no muestra ninguna ventaja competitiva 
en la modificación del movimiento del jugador, decidimos perder parte de las verificaciones en 
favor a la facilidad de desarrollo provista por Godot.

% algoritmos de colisiones son resolubles en el backend, era reiventar la rueda, ya tenemos godot <3
% y no sabíamos cómo iba a ir el tema de performance.

\subsubsection{Juego de cartas: Truco}
\noindent A modo de muestra del tipo de funcionalidades que se pueden desarrollar en conjunto de 
Godot y el modelo de actores, hemos implementado el juego de cartas \textbf{Truco}, específicamente 
en su versión argentina.

Al igual que con el movimiento del jugador y las colisiones, debimos decidir qué 
responsabilidades recaerían tanto para el frontend como para el backend. En la sección 
sobre el movimiento del jugador, concluímos que no existía una importante necesidad de 
validar cada movimiento del jugador, pero el caso de un minijuego como el Truco es distinto. 
En el movimiento, que los demás jugadores vean a otro jugador en una posición incorrecta es 
corregible, momentáneo e insignificante, pero en el Truco, que un jugador presencie una acción 
incorrecta es inaceptable debido a que cada acción realizada por un jugador afecta el flujo del juego.

Para poder mantener la coherencia y la integridad de una partida de Truco, se decidió dejar 
la responsabilidad del manejo de flujo y las verificaciones al backend, mientras que el 
frontend tiene la responsabilidad de mostrarle al jugador todo lo que el backend dicte, 
como por ejemplo las cartas en su mano, las jugadas de su adversario y los cantos disponibles. 
El frontend también posee la responsabilidad de ofrecerle una buena jugabilidad al jugador, 
por lo que la interfaz de juego fue diseñada con estas intenciones. Implementamos un método 
de movimiento para jugar las cartas denominado “drag and drop” para que el jugador pueda 
arrastrar las cartas en caso de que desee jugarlas o volver a colocarla en la mano con tan 
solo volver a arrastrarla a su zona original y una interfaz que muestre los cantos disponibles; 
un cartel que aparezca para avisarle al jugador que su oponente realizó un canto y que luego 
desaparezca, indicadores de a qué jugador le corresponde realizar una jugada, entre otras cosas.


\subsection{Protocol buffers}

\noindent Tanto la comunicación por TCP entre Cliente y Servidor, como el envío de eventos con Kafka
requirió que definamos un protocolo de mensajes propio. Además de definir dicho protocolo, necesitamos
que sea rápido y eficiente, para mantener al mínimo la latencia entre mensajes y poder manejar
una alta cantidad de mensajes.
Es por esto que decidimos usar \textit{Protocol buffers} (o \textit{protobufs}), un mecanismo desarrollado
por Google para serializar datos estructurados, ajeno completamente a cualquier lenguaje.
El propósito es definir los mensajes del protocolo una sola vez y reutilizarlos tanto en el Cliente como el Servidor.
Otra de las razones por la cual elegimos usar esta herramienta fue que cuenta con soporte tanto para Scala como para Godot.
Esto nos permitió que, una vez definidos los mensajes en sus correspondientes archivos \textit{.proto}, podamos usarlos
directamente en el código como si fueran objetos y la herramienta se encarga automáticamente de la serializacion, ya sea para enviar
el mensaje por TCP o para encolarlo en Kafka.

\noindent El formato de todos los mensajes consiste en una sección de metadata y otra sección que contiene el contenido del mensaje específico,
más dos campos de 4 bytes cada uno que indican el largo (en bytes) total del mensaje y el de la sección de metadata.
El campo de metadata contiene a su vez dos campos: uno con el largo del contenido y otro con el tipo del mensaje.
\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{../assets/protobuf.png}
\end{figure}

Para enviar un mensaje, el flujo es el siguiente: Creamos un objeto que tenga el formato correspondiente a alguno de los
mensajes definidos. Luego, lo serializamos con el método correspondiente de protobuf (según estemos en Scala o Godot) y
calculamos la cantidad de bytes que contiene. Armamos tambien el objeto de metadata, incluyendo el largo calculado y el tipo
del contenido y lo serializamos. Luego, calculamos su largo y calculamos el largo total del mensaje y lo incluimos al principio
del mensaje.

Para leer un mensaje recibido el flujo es el contrario: Leemos los primeros 4 bytes que nos indican el largo
total del mensaje. Luego, leemos los 4 bytes con la cantidad de bytes de metadata. Con esta información, podemos leer
el campo de metadata, que a su vez nos indica el tipo y el largo del contenido. Finalmente, al saber el tipo del contenido, lo
deserializamos para luego poder manejarlo correctamente.

Los mensajes de contenido están definidos en archivos \textit{.proto}. Por ejemplo, veamos el siguiente
mensaje que definimos para el movimiento de un usuario:
\begin{verbatim}
    message PBPlayerVelocity {
        required float x = 1;
        required float y = 2;
    }

    message PBPlayerPosition {
        required float x = 1;
        required float y = 2;
    }

    message PBPlayerMovement {
        required PBPlayerVelocity velocity = 1;
        required PBPlayerPosition position = 2;
    }
\end{verbatim}

El mensaje que el Cliente enviará es \textbf{PBPlayerMovement}, que incluye otros dos mensajes:
\textbf{PBPlayerVelocity} y \textbf{PBPlayerPosition}, ambos vectores bidimensionales representados
por sus coordenadas en \textbf{x} e \textbf{y}. De esta forma cuando el usuario controla y mueve a
su personaje, el Cliente se lo comunica al Servidor creando una instancia de \textbf{PBPlayerMovement}
con los valores correspondientes, serializandolo y finalmente enviándolo.

La totalidad de los mensajes que definimos en nuestro protocolo está en el Anexo \ref{apendix:protobuf}