% En esta sección se presenta una breve descripción de la solución que se propone, 
% el principal objetivo de esta sección es poder dar el bosquejo de la solución 
% para que pueda ser evaluado. No es necesario detalles, pero sí mencionar sus 
% componentes generales. 
% Si las tecnologías que se van a utilizar ya están establecidas, se deberán 
% incluir aquí. De no estar definidas todas, enumerar las que sí están definidas 
% y explicar qué consideraciones tendrán en cuenta para definir las restantes.

Proponemos una arquitectura distribuida totalmente opuesta al modelo monolítico clásico, 
donde el estado del juego no se encuentra condensado en una única máquina sino que se encuentra 
distribuido en varias. El conjunto del estado en cada una de estas terminaría siendo el 
estado del juego global. Además de esto, proponemos que utilizar el modelo de actores resulta 
una forma natural de representar a las entidades del videojuego, donde podemos plantear una 
relación 1 a 1 entre entidad y actor. Si planteamos entonces que el estado de cada entidad 
debería ser administrado por ella misma, (¡uno de los principios del modelo de actores!) 
se desprende que el paradigma de actores se ajusta perfectamente al modelo que queremos desarrollar.

Existen muchas implementaciones del modelo de actores (el lenguaje \textit{Erlang} o el framework de 
\textit{Rust actix}) pero nosotros nos decantamos por \textit{Akka}.


\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\textwidth]{../assets/architecture.png}
    \caption{Diagrama de arquitectura propuesta utilizando el modelo de actores y streams}
\end{figure}

Para solucionar el problema mencionado anteriormente, planteamos desde el diseño tener al juego 
dividido en “secciones” o “niveles” (que no necesariamente sean niveles o zonas físicas distintas) 
donde los actores correspondientes a cada entidad únicamente conocerán (y por tanto podrán interactuar) 
con actores de su misma zona o zonas adyacentes. Esto nos acota la carga de mensajes sobre cada actor, 
ya que si cada actor pudiera comunicarse con cualquier otro, terminaremos teniendo un carga de 
N cuadrado, donde N denota a los actores del juego (las entidades).

Los entidades podrán interactuar entre ellas a través de los mensajes entre los actores, 
sin embargo optamos por utilizar \textit{Akka Streams} para todo lo que sea actualizaciones globales 
del estado para evitar el problema de saturar las mailboxes de los actores ante eventos muy 
recurrentes, como es el claro ejemplo de las actualizaciones de las posiciones de los actores. 
La idea es que cada entidad tendrá asociada un actor por zona del juego encargado de leer del 
Stream de esa zona y agrupar varias de las actualizaciones de estado más generales (en forma de batch) 
y enviar por mensaje al actor principal de la entidad esas actualizaciones. 
Así disminuimos considerablemente la cantidad de mensajes que tiene que procesar cada actor 
principal de la entidad y además aprovechamos el mecanismo de back pressure que Akka Stream 
provee transparentemente. Cada actor principal de la entidad entonces envía sus actualizaciones 
generales (por ejemplo la posición) a través del Stream de la zona en la que reside, para que 
sea consumida por los actores de las demás entidades.



\subsection{Backend: servidor distribuido Akka}
\index{Desarrollo}

\subsubsection{Introducción a Akka}

\subsubsection{Arquitectura}

\subsubsection{Diagramas}

\subsubsection{Mensajes de Kafka}


\subsection{Frontend: cliente Godot}

\textit{Godot} es un motor para desarrollar videojuegos, argentino, gratuito y de código abierto. 
Este motor brinda distintas herramientas para desarrollar aplicaciones interactivas, como por ejemplo 
interfaces gráficas, gráficos 2D y 3D, input del usuario con distintos periféricos, control de audio, 
lógica de físicas y colisiones, conectividad a través de la red, entre muchas otras.
Además de permitir desarrollar para múltiples plataformas, permite programar scripts exponiendo una 
API orientada a objetos en los lenguajes C++, C\# e incluso GDScript, un lenguaje propio de Godot.

El motor ofrece una amplia colección de Nodos, que son los componentes básicos que se utilizan para 
construir Escenas, que a su vez pueden ser sub-nodos de otras escenas. Los Nodos pueden ser desde un 
simple botón (\textbf{Button}) hasta un cuerpo con lógica de físicas y colisiones tridimensionales 
(\textbf{PhysicsBody3D}) e incluso un \textbf{AnimationPlayer} que se encarga de manejar animaciones, 
es decir, una secuencia de imágenes o \textit{Sprites}.

Otro feature importante de Godot es el uso de señales (\textit{signals}) para comunicar eventos entre nodos.
Un Nodo cualquiera o una Escena personalizada pueden emitir \textit{signals} con un nombre específico 
(incluso con parámetros) para que otros Nodos o Escenas se suscriban a dicha señal. Al suscribirse, los 
Nodos receptores definen un handler (comúnmente nombrado \textit{\_on\_node\_signal\_name}) para manejar 
la señal recibida. De esta forma se pueden crear escenas compuestas de múltiples Nodos distintos, con 
comportamiento más complejo, pero sin acoplar todos los nodos que necesiten comunicarse entre sí.

La filosofía del diseño de Godot es construir escenas reutilizables usando nodos. A estas escenas y 
nodos se les puede agregar comportamiento con \textit{scripts}. Con la composición y jerarquía de los Nodos, 
se puede construir una lógica de juego que es clara y fácil de entender.

\subsubsection{Estructura de proyecto}

Para este proyecto, definimos una Escena \textbf{Main} donde instanciamos las escenas del juego necesarias 
a medida que sean requeridas. Por ejemplo, los niveles propiamente dichos no se instancian al iniciar el 
juego, sino después de que el jugador se haya conectado al servidor. De esta forma, encapsulamos todas las 
escenas activas en un mismo lugar y no desperdiciamos recursos instanciando todas las escenas a la vez.

Además hacemos uso de los \textbf{Autoloads} de Godot, que funcionan igual que el patrón \textbf{Singleton}, 
para ciertas Escenas o scripts que son necesarios en un scope global. Por ejemplo, para el manejo, carga 
y borrado de escenas, hacemos uso de un \textbf{SceneManager}, que es un script Autoload que permite 
transicionar entre niveles dentro del juego. En general, se implementaron Singletons de tipo \textit{Manager}
para acceder a distintos comportamientos y configuraciones globales (información del jugador, cambio de 
escenas, control del audio, entre otros).

\subsubsection{Comunicación con el servidor}

Al comienzo del proyecto, un posible limitante de usar Godot eran las herramientas que podía ofrecer 
el motor para la conectividad con el servidor, ya sea UDP, TCP o incluso HTTP. 
Para nuestro beneficio, Godot provee distintas APIs para conectividad que cumplen los requisitos
de los protocolos antes mencionados. En nuestro caso, decidimos usar el protocolo TCP por sus características:
\begin{itemize}
    \item Handshake con el Servidor
    \item Conexión mantenida con el Servidor
    \item Garantía de recepción de todos los paquetes enviados
    \item \textit{Flow Control}
\end{itemize}

Luego, definimos nuestras propias clases \textit{wrapper} para establecer la conexión al servidor y el 
manejo de mensajes. 

Para la recepción implementamos un \textbf{ServerConsumer} que se encarga de recibir los paquetes 
del Servidor, parsea el mensaje completo (ver sección Protocol buffers) y según qué mensaje recibió, 
invoca al \textit{handler} correspondiente para actualizar el estado del juego del lado del Cliente.

Es análogo el envío de mensajes en el sentido desde el Cliente hacia el Servidor: algún input de un 
usuario dispara una \textit{signal} que el \textbf{ServerProducer} recibe, este se encarga de crear 
el mensaje correspondiente con los parámetros correctos, lo serializa y envía los paquetes de bytes 
al Servidor a través de la conexión TCP.

\subsection{Comunicación entre cliente y servidor}

\subsubsection{Protocol buffers}

La comunicación entre Cliente y Servidor requirió que definamos un protocolo de mensajes propio para 
el envío de acciones del Cliente y las correspondientes actualizaciones del Servidor.
Para esto no solo necesitamos definir un protocolo de mensajes, sino además que sea rápido y eficiente, 
para mantener al mínimo la latencia entre mensajes.
Es por esto que decidimos usar \textit{Protocol buffers} (o \textit{protobufs}). Los 
\textit{Protocol buffers} son un mecanismo para serializar datos estructurados, ajeno completamente 
a algún lenguaje. El propósito es definir los mensajes del protocolo una sola vez y reutilizarlos 
tanto en el Cliente como el Servidor.
Por ejemplo, veamos el siguiente mensaje que definimos para el movimiento de un usuario:
\begin{verbatim}
    message PBPlayerVelocity {
        required float x = 1;
        required float y = 2;
    }

    message PBPlayerPosition {
        required float x = 1;
        required float y = 2;
    }

    message PBPlayerMovement {
        required PBPlayerVelocity velocity = 1;
        required PBPlayerPosition position = 2;
    }
\end{verbatim}

El mensaje que el Cliente enviará es \textbf{PBPlayerMovement}, que se compone de otros dos mensajes: 
\textbf{PBPlayerVelocity} y \textbf{PBPlayerPosition}, ambos vectores bidimensionales representados 
por sus coordenadas en \textbf{x} e \textbf{y}. De esta forma cuando el usuario controla y mueve a 
su personaje, el Cliente se lo comunica al Servidor creando una instancia de \textbf{PBPlayerMovement} 
con los valores correspondientes, serializandolo y finalmente enviandolo.

% TODO: seria mejor moverlo a un apendice?
A continuación listamos todos los mensajes \textit{protobuf} definidos:

\begin{table}[htbp]
    \centering
    
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Mensaje} & \textbf{Atributos} & \textbf{Quién lo envía} \\
        \hline
        PBPlayerMovement & required float x & Cliente \\
                         & required float y & \\
        \hline
        PBPlayerVelocity & required float x & Cliente \\
                         & required float y & \\
        \hline
        PBPlayerPosition & required PBPlayerVelocity velocity & Cliente \\
                         & required PBPlayerPosition position & \\
        \hline
        % Add more rows here
    \end{tabular}
    \caption{Mensajes Protobuf}
    \label{tab:my_table}
\end{table}


\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{../assets/protobuf.png}
\end{figure}

\subsubsection{Lógica del juego: movimiento y colisiones}

\subsubsection{Juego de cartas: Truco}
A modo de muestra del tipo de funcionalidades que se pueden desarrollar para el juego, hemos implementado 
el juego de cartas \textbf{Truco}, específicamente en su versión argentina.