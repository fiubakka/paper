% Esta sección se usará para explicitar la metodología general de trabajo en 
% el proyecto, incluyendo los roles de los tutores y los estudiantes.
% Como el proyecto va a incluir el desarrollo de un producto, sea de software 
% o un sistema de software-hardware (sistemas embebidos o ciberfísicos), 
% se debe usar esta sección también para especificar el proceso de desarrollo 
% del producto.
% Si hay cuestiones metodológicas no definidas, explicitarlo y explicar 
% brevemente de qué depende la decisión.
% Como todo proyecto tiene riesgos, deberá haber una lista de los riesgos 
% iniciales del proyecto.

\subsection{Metodología de trabajo}

\noindent Inicialmente, la intención fue de desarrollar el trabajo siguiendo una metodología ágil, más específicamente, Scrum.
Es decir, dividimos el período total de desarrollo del Trabajo (desde Agosto 2023 hasta Julio 2024) en Sprints de duración fija,
donde cada uno incluía reuniones de planificación, review, dailies y también las reuniones necesarias con nuestro tutor.

\noindent Entrando más en detalle sobre la metodología planeada, definimos la duración de los Sprints en dos semanas. Con respecto a
la planificación, comenzamos usando la herramienta Trello, donde creábamos las tareas a desarrollar durante el Sprint, le asignábamos
el integrante responsable y los story points correspondientes. Para definir cuantos story points eran asignados a una tarea, usamos la
técnica conocida como \textit{Planning Poker}, que consiste en definir un sistema de puntos (en nuestro caso, decidimos usar la secuencia
de Fibonacci) y luego cada integrante, sin saber las elecciones de los otros, le asigna el puntaje que considera. Una vez que todos
eligieron un puntaje, se muestra la decision de todos, y el puntaje final de la tarea es definido por mayoría. La reunión de review sería
al final del Sprint, y allí repasaríamos lo desarrollado durante las pasadas dos semanas. Finalmente, coordinamos con nuestro tutor para tener reuniones aproximadamente cada 2 semanas, donde mostraríamos el avance hasta el momento,
validar que estemos en el camino correcto y también ayudar a definir el trabajo de los proximos Sprints.

En la realidad, las cosas fueron ligeramente diferentes. Si bien mantuvimos la separación en Sprints de dos semanas, algunas reuniones
fueron dejadas de lado completamente luego de los primeros Sprints, ya que nos dimos cuenta que no nos aportaban tanto como pensabamos
inicialmente.
Las reuniones de planificación fueron las primeras que dejamos de hacer. Esto se debió a que al empezar el proyecto, las 
dos tecnologías principales que elegimos usar eran completamente nuevas para todo el grupo, lo que causó que una porción considerable de
los primeros Sprints fuera dedicada exclusivamente a la investigación y familiarización tanto con Godot como con Akka. Esto causó que al
comienzo, estas primeras tareas fueran difíciles de planificar y puntuar, ya que había demasiada incertidumbre. Dado esto, decidimos dejar
de lado las reuniones de planificación, y nunca las retomamos.
Por otro lado, nos dimos cuenta que dar updates pequeños en alguno de los canales de comunicación que usamos (Discord, Whatsapp) era suficiente
como reemplazo de las \textit{dailies}.
Las reuniones de review al final de cada Sprint fueron mantenidas acorde al plan inicial.
Por su lado, las reuniones con el tutor las seguimos haciendo, pero con una frecuencia variable.

\subsection{Desarrollo del proyecto}
Una vez definidas las tecnologías en las cuales íbamos a trabajar, Akka para el servidor y Godot para el cliente, decidimos separarnos
en dos grupos de dos integrantes cada uno. Iván y Marcos con Akka, Franco y Nicole con Godot. Al principio, cada grupo se enfocaría en 
familiarizarse con la tecnología correspondiente e ir haciendo pruebas de concepto relacionadas al proyecto. Por ejemplo, para Akka 
comenzamos a modelar un jugador, agregando los mensajes necesarios para la lógica del movimiento. Por otro lado, en Godot, en lo que primero
se trabajó también fue el movimiento, sumado a como mostrar al personaje con gráficos acordes a su orientación.
Llegó un punto donde el cliente empezó a necesitar más trabajo que el servidor, por lo que la separación en grupos se fue desarmando y
todos desarrollábamos en donde era requerido.

Como se explica en la sección 6.6.1, durante los primeros Sprints de desarrollo, el cliente enviaba los inputs de movimiento al servidor y esperaba una respuesta con la
la posición resultante de ese movimiento. Como en ese momento el servidor no estaba completamente funcional, decidimos crear una especie de servidor
\textit{mock} para simular el comportamiento del real. Este servidor fue desarrollado en Python, y se encargaba simplemente de escuchar mensajes por TCP
y devolver una respuesta. Esto permitió que el grupo que trabajaba en Godot no quedara bloqueado en el desarrollo del movimiento del jugador
hasta que el servidor en Akka llegase a un estado funcional.

Una vez que la comunicación entre el servidor y el cliente fue establecida, y definimos el protocolo detallado en la sección 6.4, que consiste en
múltiples mensajes de protobuf, nos dimos cuenta de que íbamos a tener que definir dichos mensajes tanto en el servidor como en el cliente. Eso iba
a generar mucho código repetido, lo que a su vez aumentaría la probabilidad de tener algún error donde el mismo mensaje fuera definido de
forma distinta en los dos proyectos. Es por eso que decidimos unificar todos los mensajes en un repositorio aparte, que utilizando submodulos
de Git, se vería como un directorio y se mantendría igual en ambos proyectos, lo que evitaría el error mencionado anteriormente.
Entonces, para agregar o editar un mensaje, se debía agregar el archivo al repositorio y luego, en el repositorio de cada uno de los proyectos, 
ejecutar el comando \texttt{git submodule --update} para actualizar. Una vez hecho esto, los mensajes de proto debían ser compilados para poder
ser usados en el código. En el servidor, esto se hacía automáticamente al levantar el proyecto. Por otro lado, para el cliente, armamos un
script en Bash llamado \textit{gobuf-compile.sh} que se encargaba de compilar todos los mensajes y guardar el resultado en otra carpeta que 
luego sería subida al repositorio, para no tener que hacer la compilación múltiples veces.
