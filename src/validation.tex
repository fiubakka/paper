% Aquí se debe definir un conjunto de pruebas que serán entregadas como 
% resultado final del proyecto y verificación del mismo. 
% Las mismas podrán ser ajustadas más adelante.

\noindent Inicialmente, partimos de la premisa de que nuestra arquitectura distribuida era naturalmente más escalable horizontalmente
que una arquitectura monolítica. En esta sección realizaremos diversas pruebas con distintas configuraciones de nodos del servidor y cantidad
de jugadores conectados para validar esta hipótesis. Para facilitar estas pruebas y hacerlas reproducibles, utilizaremos los Bots desarrollados
en la sección \ref{sec:Bots}. Las pruebas fueron realizadas en el entorno de Kubernetes descrito en la sección TODO, que es actualmente el entorno
productivo de \textit{Fiubakka}, pero es posible realizar estas pruebas sin necesidad de un ambiente de Kubernetes, mediante múltiples instancias del
servidor en una misma máquina.

Como aclaración previa a las pruebas, el cluster de Kubernetes utilizado cuenta con un nodo con una CPU aproximadamente el doble de rápida que los otros dos nodos.
Todas las pruebas que involucren menos de la totalidad de los nodos únicamente utilizarán los nodos más lentos para mantener uniformidad en los resultados.
Igualmente, a los efectos del resultado esperado, es esperable que dada una utilización de CPU \textit{x} en un nodo del servidor, se reduzca aproximadamente a
$\frac{x}{n}$ donde \textit{n} es la cantidad de nodos del Akka cluster. Esta proporción es independiente de los recursos de cada nodo de Kubernetes. Por otro lado,
otro de los nodos cuenta con 4GiB de memoria RAM a diferencia de los otros dos nodos, que cuentan con 8GiB. A continuación se detalla un cuadro con los recursos disponbiles
de cada nodo.

\begin{center}
    \begin{tabular}{|c|c|c|c|}
    \hline
    \textbf{Nodo} & \textbf{Núcleos del procesador} & \textbf{Velocidad del procesador} & \textbf{Memoria RAM} \\
    \hline
    raspberrypi1 & 4 & 1.8GHz & 8GiB \\
    \hline
    raspberrypi2 & 4 & 1.8GHz & 4GiB \\
    \hline
    raspberrypi3 & 4 & 2.4GHz & 8GiB \\
    \hline
\end{tabular}
\end{center}

Lógicamente, para cada prueba realizada se adjuntará el nodo de Kubernetes en el que se ejecutó el \textit{pod}, para poner en referencia los recursos utilizados.

\subsection{Recursos utilizados por un nodo de \textit{Fiubakka}}

\noindent Comenzamos con la prueba más simple, un único nodo del cluster de \textit{Fiubakka} en \textit{idle}, esto es, sin ningún jugador conectado.
Para obtener las métricas de recursos utilizados por la aplicación debemos observar los recursos reportados por el \textbf{pod} en Kubernetes.
Es importante tener en cuenta que Kubernetes reporta el consumo de CPU en \textit{millicores}. Por ejemplo, 1000m representa 1000 \textit{millicores}, equivalente
a 1 core de la CPU del nodo de Kubernetes en el que se encuentre el pod. Kubernetes es agnóstico a la velocidad del procesador en sí, en la práctica lo que tiende a suceder
es que nodos más rápidos que otros reportan un consumo de CPU menor para la misma tarea.

\noindent El resultado obtenido es el siguiente:

\begin{center}
\begin{tabular}{|c|c|c|}
    \hline
    \textbf{Nodo de ejecución} & \textbf{Consumo de CPU} & \textbf{Consumo de memoria} \\
    \hline
    raspberrypi1 & 269m & 244Mi \\
    \hline
\end{tabular}
\end{center}

\noindent Para demostrar el punto anterior sobre el consumo de CPU en nodos más rápidos, este es el resultado para el nodo \textbf{raspberrypi3}:

\begin{center}
    \begin{tabular}{|c|c|c|}
    \hline
    \textbf{Nodo de ejecución} & \textbf{Consumo de CPU} & \textbf{Consumo de memoria} \\
    \hline
    raspberrypi3 & 118m & 274Mi \\
    \hline
\end{tabular}
\end{center}

\noindent Vemos que es aproximadamente la mitad del consumo de CPU respecto al nodo \textbf{raspberrypi1}. Esto es coherente con lo mostrado en el cuadro de recursos de cada
nodo.


\subsection{Resultados esperados}

\subsection{Resultados obtenidos}

\subsection{Métricas de latencia}

\subsection{Requisitos del sistema para el juego}

\noindent Si bien el frontend no es el foco del proyecto, es importante tener en cuenta cuáles son los 
requisitos mínimos del sistema para correr el cliente del juego. Es decir, qué tipo de CPU se necesita,
cuánta capcidad en memoria RAM y cuánto espacio ocupa en disco. Es importante mantener estos requisitos
bajos, para lograr que el juego corra en la mayor cantidad de máquinas posibles y por lo tanto,
que la mayor cantidad de gente pueda jugarlo.

El archivo ejecutable del juego exportado ocupa \textbf{113,7 MB} (en la versión Linux) en disco.

Además es necesario disponer de al menos \textbf{490 MB} de memoria RAM para ejecutar el juego.
En casos de computadoras sin una placa gráfica dedicada, este requisito de memoria principal puede subir
hasta \textbf{1 GB}, debido a que la VRAM necesaria se consume de la RAM.

Respecto a los requisitos de CPU, estos son más dificiles de medir, debido a que existe una gran cantidad
de modelos de microprocesadores comerciales, cada uno con una combinatoria aún mayor de posibles
configuraciones y \textit{performances}. Sin embargo, existe una guía en la documentación de Godot\cite{ref3}
con los requisitos mínimos y recomendados para un proyecto 2D o 3D exportado.
Usando esta guía de referencia y teniendo en cuenta que el juego no es muy intensivo en cuanto a cantidad
de cómputo (ya que la mayor parte del tiempo se están enviando y recibiendo paquetes de red), decidimos
tomar como requisito mínimo de CPU el recomendado:

\[
\textit{Intel Core 2 Duo E8200} o \textit{AMD Athlon XE BE-2300}.
\]

A continuación se confecciona una tabla con todos los requisitos mínimos de sistema.

\begin{longtable}{|l|l|}
    \hline
    \textbf{CPU} & \textit{Intel Core 2 Duo E8200}\\
                 & \textit{AMD Athlon XE BE-2300}\\
    \hline
    \textbf{RAM} & 500 GB.\\
                 & 1 GB para máquinas sin placa de video.\\
    \hline
    \textbf{Disco rígido} & 113,7 MB.\\
    \hline
    \textbf{Sistema Operativo} & Sistema operativo Windows o Linux.\\
    \hline
    \caption{Requisitos mínimos del sistema.}\\
\end{longtable}

