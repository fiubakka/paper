% En esta sección se deben explicar los riesgos que se materializaron a lo largo del
% proyecto, estuvieran o no previstos al comienzo (más aún si no estaban previstos).
% Por ejemplo, desvíos en las estimaciones que hayan obligado a modificar el alcance,
% interesados con los que esperaban contar que finalmente no estuvieron disponibles, 
% metodologías o tecnologías que no funcionaron como se esperaba, y cuestiones de 
% este estilo.
% Los riesgos no previstos son per se lecciones aprendidas, pero también resulta de 
% interés explicitar qué aspectos del proyecto les dejaron lecciones positivas que 
% hayan servido para el aprendizaje.

\noindent A continuación detallamos los problemas encontrados a lo largo del desarrollo del
Trabajo Profesional. Estos problemas fueron en su mayoría imprevistos que o bien
dificultaron el progreso o bien imposibilitaron el desarrollo de ciertas partes.

\subsection{Deploy de Kubernetes a un ambiente productivo}

\subsection{Funcionalidades descartadas}

Si bien se lograron implementar tanto la arquitectura del Servidor distribuido que es el objeto
de estudio de este Trabajo así como también el juego que funciona como interfaz de aplicación
para los usuarios, existen algunas funcionalidades para el juego que fueron inicialmente
planeados pero por restricciones de tiempo no fue posible completarlos. A continuación, listamos 
las mas interesantes:

\subsubsection{Sistema de recompensas y Tienda de items}
Así como existen muchos cosméticos para la creación del personaje y además es posible cambiarlos dentro del
juego, no existe para los jugadores alguna forma de obtener nuevos cosméticos además de los que poseen en sus
inventarios. Para solucionar esto, surgió la idea de agregar un tipo de moneda con la cuál un usuario podría comprar nuevos
items equipables. Dichos objetos podrían ser adquiridos en una tienda ubicada en el \textbf{Level} del \textbf{Comedor}.

Esta funcionalidad hubiese estado relacionada al \textbf{Truco}, ya que la adquisición de esta moneda
sería una recompensa por ganar partidas de \textbf{Truco}.

\subsubsection{Foro de consultas}
Teniendo en mente la temática de una facultad, donde uno suele juntarse con profesores y/o compañeros de clase
para intercambiar ideas o hacer consultas, también se pensó en implementar un foro de consultas donde un usuario
podría realizar un \textit{post} a modo de consulta y los demás usuarios podrían responder a la misma. Tanto el \textit{post}
original como las respuestas podrían recibir votos positivos o negativos de parte de cualquier usuario, con el fin
de poder votar la "mejor respuesta". Esta funcionalidad se inspira en foros y páginas de consulta como lo es por ejemplo
\textit{StackOverflow}.

Para realizar una consulta dentro del juego, un jugador podría hacerla acercandose a una pizarra y creando el \textit{post}.
Si bien el chat es una forma de comunicación por texto entre jugadores, carece de la persistencia necesaria que necesitaría
una consulta que puede ser respondida luego de mucho tiempo, ya que el log de mensajes del chat se borra cuando el jugador
cierra el juego.

\subsubsection{Clases de programación}
Una idea que surgió naturalmente dada la ambientación del juego fue la de tener minijuegos relacionados a distintas materias
de la facultad. De todos los minijuegos que se nos ocurrieron, el más interesante era sin dudas el que apuntaba a simular
una clase de programación. El jugador ingresaría a una sala similar a los laboratorios del piso 4 y al interactuar con una
computadora, vería una interfaz como si fuera un \textit{IDE}. Allí tendría una consigna y la posibilidad de escribir código.
Una vez finalizado, ese código se analizaría para ver si resolvía correctamente la consigna y en ese caso, podría pasar a una nueva
consigna mas compleja.
% TODO: Como íbamos a mandar el codigo? Me suena que era con Kafka, pero nose si ya habiamos encontrado una herramienta
% para analizar el codigo submiteado

\subsection{Godot Editor}

\subsubsection{Godot: Optimización de imágenes}

En cierto punto del desarrollo, nos encontramos con que cargar el proyecto en el editor de Godot
requería alrededor de 3 GB de memoria RAM y levantar una sola instancia del juego requería además
otros 3 GB extra en memoria principal. En un entorno de desarrollo donde es necesario testear
funcionalidades teniendo por lo menos dos instancias del juego corriendo a la vez, esto dificultó e incluso
imposibilitó para algunos integrantes continuar normalmente con el desarrollo. Este requerimiento
de RAM no parecía tener sentido, ya que la suma del espacio requerido en disco de todos los 
\textit{assets} de nuestro proyecto no superaba los 100 MB.

Luego de investigar más a fondo el problema y entender cómo estábamos cargando los archivos de imágenes,
entendimos mejor el mecanismo que usa Godot para importar imágenes y qué implica eso.

Al agregar una imágen al proyecto, Godot genera autmáticamente un archivo con el mismo nombre y extensión 
\textit{.import}, con metadata y configuraciones del archivo. 
Por ejemplo, para el caso de las imágenes, es posible configurar el modo de compresión, generación de 
\textit{mipmaps}, entre otras opciones. Godot un modo de compresión \textbf{Lossless} por defecto. 
Si bien este modo tiene la ventaja de que no genera \textit{artifacts} visuales en las imágenes importadas, usa 
considerablemente más memoria VRAM (\textit{Video Random Access Memory}) para almacenar la textura o
imágen importada, en comparación con otras opciones de compresión disponible.
La documentación de Godot\cite{ref2} provee un estimado del espacio que ocupa una sola textura
RGBA8 en la VRAM, dependiendo de las dimensiones de resolución de la imágen y del método de compresión utilizado.
En nuestro caso, como tenemos una imágen \textit{spritesheet} por cada variante de cada cosmético posible para los jugadores,
contábamos con más de 100 imágenes de más de 2048 x 2048 pixeles cada una. 

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1.0\textwidth]{../assets/godot-docs-images.png}
    \caption{Cuadro comparativo del tamaño que ocupa una imágen en VRAM según la resolución
             de la misma y el modo de compresión utilizado.}
\end{figure}

Usando de referencia la tabla de la documentación, y considerando que nuestras imágenes superaban
los 2048 x 2048 pixeles, además de estar usando el método de compresión Lossless,
la memoria en VRAM requerida para nuestro juego alcanzó una cota mínima de \textbf{2.24 GB}:

\[
\frac{21.33 \, MiB}{imagen} \times 100 \, imagenes = 2.24 \, GB
\]

Para computadoras sin una placa de gráficos dedicada, en lugar de alocar este espacio en VRAM,
se aloca en memoria principal RAM, generando los problemas anteriormente mencionados.
Habiendo entendido la causa de la problemática, aplicamos 2 soluciones para solventarla:

\begin{itemize}
    \item Reducir el tamaño de las imágenes recortándolas, ya que en realidad usamos solo
    una porción de la \textit{spritesheet}.
    \item Cambiar el modo de compresión de los cosméticos para personajes de \textbf{Lossless}
    a \textbf{VRAM Compressed}, para reducir aún más el espacio ocupado de VRAM. Si bien este
    modo de compresión no es recomendado para texturas 2D, especialmente del estilo
    \textit{pixel art} como lo es nuestro juego, al correr el juego usando este método de compresión
    no se notaron defectos ni \textit{artifacts} visuales.
\end{itemize}

Tras haber implementado estos cambios, logramos reducir la memoria requerida por una instancia
del juego a menos de 1 GB.

\subsubsection{Control de versiones}

Uno de esos problemas está relacionado al control de versiones. Cada escena o nodo creado posee 
un archivo autogenerado por Godot en el cual se ven reflejados los cambios que realizamos desde 
el motor de videojuegos. No es usual que este archivo sea modificado manualmente, sino que toda 
modificación se realiza a través de la interfaz de Godot. Al realizar un merge con Github, si 
varias personas modificaron una misma escena o nodo, podría ocurrir que hubieran conflictos en 
dichos archivos autogenerados y al modificarlos manualmente, se eliminaran o modificaran líneas 
que terminaban ocasionando comportamientos no deseados en el juego.

Por ejemplo, para satisfacer los conflictos de un archivo podría haberse eliminado una signal 
que activaba alguna funcionalidad al presionarse un botón, y al no considerar que este botón 
podría dejar de funcionar al realizar el merge de Github, este error era descubierto una 
vez que deseáramos presionar el botón. Debido a que el error fue introducido en un merge y 
no momentos antes de presionar dicho botón, la búsqueda del error podía tornarse complicada 
o confusa. Para prevenir estos problemas, observamos con más detenimiento los archivos 
autogenerados al momento de realizar merges y al momento de realizar code reviews, 
incluso dejando comentarios en los pull request preguntando si realizar dichos cambios 
es el comportamiento que el dueño del pull request está buscando.

\subsubsection{Uso de signals}

Otro problema fue el acoplamiento de las escenas y los nodos. Durante gran parte del proyecto, 
la mayoría de los nodos se comunicaban con sus nodos hijos de la siguiente manera:

\begin{lstlisting}
    $nodo.metodo()
\end{lstlisting}

En un inicio, esta forma parecía resultar cómoda para poder llamar a los métodos de los nodos 
hijos, pero poseía un problema y era que el código se volvía difícil de reutilizar y refactorizar. 
Al utilizar signals en lugar de llamar a los métodos de los hijos de esta forma, no es necesario 
que el nodo padre y los nodos hijos conozcan detalles de la implementación del otro, aumenta 
la modularización, se puede intercambiar a los hijos de un nodo sin necesidad de modificar el 
código del padre, mejora la escalabilidad, por mencionar algunas ventajas.

\subsubsection{Convención en el nombramiento de callbacks}

Relacionado al uso de señales, otro de los problemas que surgió es no seguir la convención de 
Godot al nombrar los callbacks creados manualmente para conectar a las señales:

\begin{lstlisting}
    _on_<nombre_del_nodo>_<nombre_de_la_signal>()
\end{lstlisting}

Al no saber qué nodo va a responder a una señal emitida, utilizar esta convención hace más 
fácil la búsqueda en el código.
